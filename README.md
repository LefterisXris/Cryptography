# Cryptography

This project is developed during the course of "Cryptography" in University of Macedonia.

I developed some python scripts, using [Sage math cloud version](https://cloud.sagemath.com/).

There are two files. One for each Task that I had to complete.

In the Task 1 I had to work with classic Cryptosystems.

In the Task 2 I had to face more recent Cryptosystems.

#***************************************************

##TASK 1: 
###Κρυπταλγόριθμος Μετατόπισης (Shift Cipher)  <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**shiftCipherEnc(pl, k)**: Η συνάρτηση υλοποιεί την κρυπτογράφηση με τον κρυπταλγόριθμο μετατόπισης<br>
**shiftCipherDec(ct,k)**: Η συνάρτηση υλοποιεί την αποκρυπτογράφηση με τον κρυπταλγόριθμο μετατόπισης<br>

####Βοηθητικές συναρτήσεις
**str2lst(s)**: παίρνει ένα αλφαριθμητικό και επιστρέφει σε λίστα τις αριθμητικές τιμές των χαρακτήρων του αλφαριθμητικού.<br>
**lst2str(lst)**: αντίθετη λειτουργία της **str2lst(s)**.<br>

###---------------------------------------------------<br>

###Κρυπταλγόριθμος Αντικατάστασης (Transposition Cipher) <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**subCipherDec(c, key)**: Η subCipherDec αποκρυπτογραφεί το κείμενο c με βάση το κλειδί key.<br>

####Βοηθητικές συναρτήσεις
**CreateKey(sorted_freq, engFreq)**:  Η CreateKey, δοσμένης της λίστας με τις συχνότητες (ταξινομημένες) καθώς και με τα πιο συχνά γράμματα της αγγλικής, κάνει την αντιστοίχηση ώστε να παραχθεί το κλειδί.<br>
**replaceChar(li, old, new)**:Η replaceChar αντικαθιστά έναν χαρακτήρα (old) σε μια λίστα (li) με έναν άλλο χαρακτήρα (new)<br>
**findFreqs(freq)**: Η findFreqs, παίρνει ως είσοδο τις συχνότητες εμφάνισης τωνς γραμμάτων σε ένα κείμενο αλφαβητικά και τις ταξινομεί με φθίσουσα σειρά.<br>

###---------------------------------------------------<br>

###Ομοπαραλληλικός κρυπταλγόριθμος (Affine Cipher)  <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**affine_enc(m, key1, key2)**: Κρυπτογράφηση Ομοποραλληλικού κρυπταλγορίθμου.<br>
**affine_dec(c, key1, key2)**: Αποκρυπτογράφηση Ομοπαραλληλικού κρυπταλγορίθμου.<br>
**affine_number_enc(m, k1, k2, mod)**: Ορίζω ξανά την κρυπτογράφηση για αριθμούς.<br>
**affine_number_dec(c, k1, k2, mod)**: Ορίζω ξανά την αποκρυπτογράφηση για αριθμούς.<br>

####Βοηθητικές συναρτήσεις
**affine_analysis(plaintext, ciphertext)**: Λύση συστήματος εξισώσεων για εύρεση κλειδιών.<br>
**affine_analysis_num(p1, p2, c1, c2)**: Ορίζω ξανά την ανάλυση για αριθμούς.<br>

###---------------------------------------------------<br>

###Βάση εκφώνησης Ομοπαραλληλικός Κρυπταλγόριθμος (Custom Affine Cipher) <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**custom_affine_enc(m, k1, k2, k3)**: Κρυπτογράφηση<br>
**custom_affine_dec(ct, k1, k2, k3)**: Αποκρυπτογράφηση<br>

####Βοηθητικές συναρτήσεις
**check_b(b)**: Ελέγχει αν το b είναι σχετικά πρώτος με το 26. Στην ουσία αν κάνει για κλειδί.<br>
**custom_affine_analysis(plaintext, ciphertext)**: Ανάλυση κρυπτοσυστήματος για εύρεση πιθανών κλειδιών.<br>

###---------------------------------------------------<br>

###Κρυπταλγόριθμος Hill (Hill Cipher)  <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**Hill_enc(m, K)**: Η συνάρτηση υλοποιεί την κρυπτογράφηση με τον κρυπταλγόριθμο Hill.<br>
**Hill_dec(c, K)**: Η συνάρτηση υλοποιεί την αποκρυπτογράφηση με τον κρυπταλγόριθμο Hill.<br>

####Βοηθητικές συναρτήσεις
**check_valid(K)**: Ελέγχει αν ο πίνακας K είναι αντιστρέψιμος, στην ουσία αν είναι δυνατό (πιθανό) κλειδί.<br>

###---------------------------------------------------<br>

###Κρυπταλγόριθμος γινομένου (Product Cipher)  <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**Ek1 (p, k)**: Δέχεται ως είσοδο plaintext (p) και key (k) και κάνει πράξη XOR μεταξύ τους.Επιστρέφει το αποτέλεσμα στο δεκαδικό.<br>
**Ek2(P)**: Κάνει permutation τα bit του P με βάση το (p4 p2 p6 p5 p3 p1) και επιστρέφει το αποτέλεσμα στο δεκαδικό.<br>

###Η κρυπτογράφηση πρακτικά είναι το γινόμενο των δύο συναρτήσεων.<br>

###---------------------------------------------------<br>

###Κρυπτοσύστημα Pohlig - Hellman  <br>
Υλοποιείται η παρακάτω συνάρτηση. <br>

**PH(m, p, e)**: Η συνάρτηση προσομοιώνει το κρυπτοσύστημα Pohlig - Hellman. Κάνει αρχικά κωδικοποίηση, έπειτα κάνει κρυπτογράφηση, μετά βρίσκει τον αντίστροφο του κλειδιού, κάνει αποκρυπτογράφηση και τέλος αποκωδικοποίηση.<br>

###---------------------------------------------------<br>

###Συναρτήσεις για την Άσκηση 10  <br>

**Euler(n):**: Η συνάρτηση βρίσκει τους αριθμούς στο διάστημα (0,n) οι οποίοι είναι σχετικά πρώτοι με το n. Προσοχή δεν είναι ίδια με την έτοιμη συνάρτηση euler_phi(n) καθώς η έτοιμη επιστρέφει το πλήθος των αριθμών ενώ η δική μου επιστρέφει τους ίδιους τους αριθμούς.<br>
**checkEuler(n)**: Αυτή είναι ακριβώς ίδια με την έτοιμη euler_phi(n).<br>
**find4Sols(n)**: Η συνάρτηση ψάχνει τέσσερις αριθμούς για τους οποίους το φ(n) τους να ισούται με 16. Τυπώνει τους αριθμούς αυτούς.<br>
**Omada(n, g)**: Η συνάρτηση υπολογίζει την ομάδα με γεννήτορα το g, στο Zn. Επιστρέφει την ομάδα.<br>

#***************************************************<br>

##TASK 2: 
###Κρυπτοσύστημα RSA  <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**rsa_enc(m, e, n)**: Η συνάρτηση υλοποιεί την κρυπτογράφηση με τον κρυπταλγόριθμο RSA. Δέχεται ως είσοδο το μήνυμα m  και το δημόσιο κλειδί e,n και επιστρέφει το κρυπτοκείμενο.<br>
**rsa_dec(c, d, n)**: Η συνάρτηση υλοποιεί την αποκρυπτογράφηση με τον κρυπταλγόριθμο RSA. Δέχεται ως είσοδο το κρυπτοκείμενο c, το ιδιωτικό κλειδί d και το modulus n και επιστρέφει το απλό κείμενο.<br>

####Βοηθητικές συναρτήσεις
**keygen(bits)**: Δημιουργεί κλειδιά RSA, δέχεται ως είσοδο το πλήθος των bits των κλειδιών (με τιμές στο διάστημα [512,1024]) και επιστρέφει τα κλειδιά: δημόσιο και ιδιωτικό.<br>
**str2num(s)**:  Υλοποιεί την λειτουργία της κωδικοποίησης βάση του εκτεταμένου ASCII. Δέχεται ως είσοδο ένα κείμενο s και επιστρέφει έναν μεγάλο ακέραιο.<br>
**num2str(n)**: Υλοποιεί την λειτουργία αποκωδικοποίησης βάση του εκτεταμένου ASCII. Δέχεται ως είσοδο έναν μεγάλο ακέραιο n και επιστρέφει το κείμενο στο οποίο αντιστοιχεί. <br>

###---------------------------------------------------<br>

###Κινέζικο Θεώρημα Υπολοίπων (CRT)  <br>
Υλοποιείται η παρακάτω συνάρτηση. <br>

**rsa_decrt(c, d, p, q):**: Επιταχύνεται η αποκρυπτογράφηση με τον κρυπταλγόριθμο RSA. δέχεται ως είσοδο το κρυπτοκείμενο c, το ιδιωτικό κλειδί d και τους πρώτους p,q και επιστρέφει το απλό κείμενο.<br>

###---------------------------------------------------<br>

###Επίθεση κοινού modulus <br>
Υλοποιείται η παρακάτω συνάρτηση. <br>

**crack_rsa_comoda(p,q,e1,e2,c1,c2)**: Προσομοιώνει μια επίθεση κοινού modulus.

###---------------------------------------------------<br>

###Ανταλλαγή κλειδιών Diffie-Hellman  <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**public_private_pair(p, q, g, F)**: Παίρνει ως είσοδο την έξοδο της **generate_parameters** και επιστρέφει το ζευγάρι τιμών (X,x), όπου  X = g^x mod p και x∈{2,…,p−2}.<br>
**generate_secret(X,y)**: Παίρνει ως είσοδο τη δημόσια πληροφορία του άλλου μέλους της επικοινωνίας κατά την ανταλλαγή DH και την ιδιωτικό εκθέτη και επιστρέφει το κοινό μυστικό κλειδί.<br>

####Βοηθητικές συναρτήσεις
**generate_parameters(bits)**: Δέχεται ως είσοδο το πλήθος των bits ενός μεγάλου πρώτου p και επιστρέφει 4 τιμές: p, q, g και F. Θα πρέπει τα p και q να είναι πρώτοι αριθμοί τέτοιοι ώστε p=2∗q+1, g θα είναι ένας ακέραιος γεννήτορας του ℤp∗ και F ένα πεπερασμένο σώμα με p στοιχεία.<br>

###---------------------------------------------------<br>


###Πρωτόκολλο κρυπτογράφησης El Gamal  <br>
Χρησιμοποιούνται συναρτήσεις που φτιάχτηκαν πιο πριν και υλοποιείται η κρυπτογράφηση και η αποκρυπτογράφηση.<br>

###---------------------------------------------------<br>

###Το Πρόβλημα του Διακριτού Λογαρίθμου (DLP)  <br>
Δεν χρειάζονται κάποιες συναρτήσεις για την υλοποίηση. <br>

###---------------------------------------------------<br>

###Ανταλλαγή κλειδιών – ECDH  <br>
Υλοποιούνται οι παρακάτω συναρτήσεις. <br>

**ECDHKeyExchange(E, G)**: Η συνάρτηση προσομοιώνει την ανταλλαγή κλειδιών ECDH.<br>

####Βοηθητικές συναρτήσεις
**computeXx(E, P)**: Υπολογίζει τον ιδιωτικό πολλαπλασιαστή και το δημόσιο κλειδί.<br>
**computeCommonSecretKey(Y, x)**: Υπολογίζει το κοινό μυστικό κλειδί.<br>

###---------------------------------------------------<br>

###Κρυπτοσύστημα ελλειπτικού El Gamal <br>
Δεν χρειάζονται κάποιες συναρτήσεις για την υλοποίηση. <br>

###---------------------------------------------------<br>

###Κωδικοποίηση Koblitz και κρυπτοσύστημα ελλειπτικού El Gamal <br>
Δεν χρειάζονται κάποιες συναρτήσεις για την υλοποίηση. <br>

###---------------------------------------------------<br>

###Ψηφιακές υπογραφές  <br>
Υλοποιείται η παρακάτω συνάρτηση. <br>

**checkDigSig(n, e, x, s)**: Η συνάρτηση ελέγχει αν η ψηφιακή υπογραφή είναι έγκυρη.<br>

###---------------------------------------------------<br>

#END
